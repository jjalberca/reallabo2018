\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage[pdftex]{color,graphicx}
\usepackage[pdftex,
	colorlinks=true,
	pdfauthor={Alejandro Vicario Espinosa},
	pdftitle={}]{hyperref}

\graphicspath{ {curvas/} }

\begin{document}

\title{Entregable 2 \\
\large RealLabo 2018. Modelado e implementación}
\author{
	Juan José Alberca\\
	\texttt{jj.alberca@alumnos.upm.es}
	\and
	Alejandro Vicario\\
	\texttt{a.vicarioe@alumnos.upm.es}
}
\date{\today}


\maketitle


\section{Diseño e implementación de arquitectura software en el hardware del RealLabo}
\subsection{Hardware}

\subsubsection{Conexionado}
Se ha procurado hacer el conexionado lo más simple posible, intentando respetar lo máximo posible las conexiones que ya proporciona la \emph{shield} del puente en H.
Las únicas conexiones externas a la placa que se han realizado son las que provienen del motor, que son las siguientes:
la alimentación del motor no se ha cambiado y se encuentra en el canal 1 del puente en H;
la alimentación del encoder se ha conectado a alguna de las salidas de \emph{3.3V} y \emph{GND} de la placa;
los cables amarillo y blanco del encoder se han conectado en los pines \texttt{A8} y \texttt{A9} de la placa respectivamente.

\subsubsection{Obtención de PWM}
En esta sección se pretence explicar el procedimiento seguido para obtener la señal modulada en ancho de pulso (\emph{PWM}) para controlar la potencia entregada al motor.

El microprocesador cuenta con ocho periféricos \emph{PWM}, cuya única función es generar señales de este tipo. Sin embargo,
las salidas de estos periféricos son fijas y además no coinciden con los pines que se necesitan para controlar el puente en H, 4 y 5, en la placa del Arduino,
lo cual nos obligaría a utilizar un cable adicional para poder usar este periférico.

La placa también cuenta con timers los cuales pueden trabajar en modo \emph{waveform}.
Este modo permite generar una señal de diferentes características.
Configurando estos periféricos correctamente se puede generar una señal \emph{PWM} justo en el pin donde se conecta una de las entradas del puente en H: el pin 5.
Para generar esta señal se utilizó el canal 0 del \emph{timer} 2 (\texttt{TIOA6}), que coincide con la entrada \texttt{IN\_2} del puente en H.

\subsubsection{Quadrature decoder}
El \textbf{SAM3XE8} contiene un decodificador de las señales del encoder del motor en hardware,
que permite controlar su posición y/o su velocidad sin ningún software adicional, usando los canales 0, 1 y 2 del \emph{timer} 0 (\emph{TC0}) para este propósito.
Sin embargo, no es facil de integrar en este proyecto, ya que la entrada de \emph{Enable} del canal 1 del puente H, coincide con una de las entradas del decodificador (\emph{TIOA0}).
Por lo que habría que modificar la \emph{shield} para dejar las entradas \texttt{TIOA0} y \texttt{TIOB0} libres.

Por lo tanto la lectura de la posición del motor se realiza mediante interrupcciones y rutinas software.

\subsubsection{Interrupcciones}
Se ha activado una interrupción periódica del \emph{SysTick} cada milisegundo para obtener un contador fiable del tiempo transcurrido.
Se ha utlizado también otra interrupción periódica a un milisegundo usando el canal 1 del \emph{timer} 0 para realizar diversas tareas en software que requieren temporización.

Por último también se ha activado una interrupción por flanco de subida o bajada en los pines de entrada a los que está conectado el encoder para realizar la decodificación de la posición.

\subsection{Software \label{sec:software}}
El software utilizado se ha desarrollado sobre el \emph{framework} que Atmel proporciona para sus dispositivos: \textbf{Atmel Software Framework}.
Todo el código se encuentra en un repositorio de GitHub \cite{git}.

Del software cabe destacar que se ha intentado realizar la mayoría de las tareas utlizando los periféricos hardware. Por lo tanto,
la mayor parte del código consiste en drivers que sirven para inicializar estos periféricos e interactuar con las funciones de los mismo.

Para controlar el sistema se ha implementado una interfaz de comunicación con el sistema mediante el puerto serie con el objetivo de facilitar su uso.
Cuenta con un control de velocidad manual y con una rutina que realiza los test que se necesitan para obtener los datos utilizados para el modelado del motor y los vuelca
por el puerto serie para que puedan ser almacenados en un fichero.

\section{Modelado experimental de un motor DC con la arquitectura hardware y sofware implementadas}
\subsection{Experimentos realizados \label{sec:exp}}
A partir del software descrito en la sección \ref{sec:software} se han realizado test para obtener la de respuesta al escalón del motor,
tanto para condiciones iniciales nulas y no nulas.
Para esto se ha excitado el motor con una señal cuadrada que introduce un voltaje durante $600ms$ e introduce $0V$ por otros $600ms$
mientras se toman valores de los pulsos capturados por el encoder cada milisegundo.

Esta prueba se ha repetido 10 veces para cada uno de los siguiente valores eficaces de la señal de excitación:

\begin{displaymath}
V \in \{1,2,3,4,5,6,7,8,9,10,11,12\}
\end{displaymath}

Es decir, se tienen $P=10$ repeticiones de $Q=12$ experimentos. El eje del motor tiene, por su parte, una q=48 pulsos/vuelta.
El procedimiento seguido es el explicado en la sección 3.2 del documento modelado de la asignatura \cite{modelado}.

Se han promediado las P repeticiones en cada uno de los experimentos y con ello se obtienen los datos de la figura \ref{datos} que los \emph{scripts}
de Matlab proporcionados usan en sus cálculos para modelar el motor.


\begin{figure}[hbp]
	\begin{center}
		\includegraphics[width=8cm]{n_pulsos}
		\caption{Media de los datos obtenidos del motor DC.}
		\label{datos}
	\end{center}
\end{figure}

\subsection{Obtención de la función de transferencia}
El objetivo de esta sección es obtener la función de transferencia del motor a partir de los datos obtenidos en la sección \ref{sec:exp}.
Para ello se usa el modelo simplificado de está despreciando los polos no dominantes:

\begin{equation}
	\label{eq:trans}
	\dot{\theta}_m (s) = \frac{K}{s+p}
\end{equation}


Para ello se necesitan los valores medios de las velocidades angulares ($\dot{\theta}_m$) a lo largo del tiempo con cada valor de tensión utilizado.
Estos se calculan derivando los datos obtenidos sobre la posición del motor. El resultado de la derivada discreta se representa en verde en la figura \ref{velAng}.

\begin{figure}[htbp]
	\begin{center}

		\includegraphics[width=8cm]{vel_ang}
		\caption{derivada de la posicion (en verde). Ni idea (en rojo). Tampoco (en azul)}
		\label{velAng}
	\end{center}
\end{figure}

La segunda fase consiste en estudiar el régimen transitorio para realizar el cálculo del polo medio y la varianza mínima para cada valor de tensión.
En la figura \ref{polos} se pueden apreciar los 12 polos obtenidos, cuya combinación lineal explicada en la sección 3.2.2. del documento de modelado\cite{modelado}
da como resultado un polo $pM=29.9483$.

Cuando se considera el motor en régimen permanente la función de transferencia queda como:

\begin{equation}
	\label{eq:trans0}
	\dot{\theta}_m (0) = K/p
\end{equation}

A partir de la zona en la que se considera terminado el régimen transitorio se obtiene el valor de la velocidad nominal del motor para cada valor de tension.
Usando estos valores junto el valor del polo obtenido anteriormente se puede aplicar la ecuacion \ref{eq:trans0} pueden obtener los valores de ganancia $K$ indicados en la
figura \ref{valoresK}.
Usando estos valores se obtiene la ganancia media $KM=1372.1456$ y las tensiones de entrada equivalente de la tabla \ref{veq1}.

0,781896438870351	1,80423834427078	2,84086598677024	3,86129834138256	4,88237678460740	5,92278045610892	6,95228676634595	7,98034296658600	9,02004311937610	10,0379341921125	11,0426306996288	12,1643553911594

\subsection{Cuarta Fase: Identificación de la función no lineal del modelo del motor mediante
la técnica de interpolación polinómica}

Se pueden comparar con los valores de tensión introducidos con las siguientes figuras:
INSERTAR FIGURAS INSERTAR VALORES.

También se ha calculado el error cuadrático que es J=0.0918. De las figuras se pueden obtener los valores del polinomio impar de grado 12, que son
los siguientes:
INSERTAR VALORES DEL POLINOMIO

También se calcula el polinomio inverso, que serán necesario para el siguiente apartado.

\subsection{Función de transferencia}
Sabiendo forma de la función de transferencia, y viendo los datos que se han obtenido, es la siguiente:

\begin{equation}
G(s) = \frac{KM}{s+pM} = \frac{1372.1456}{s+29.9483}
\end{equation}


\subsection{Problemas encontrados durante la obtención de las gráficas de esta sección}
Como el profesor podrá recordar, nuestro grupo tubo ciertos problemas a la hora de obtener las gráficas presentadas en esta sección, concretamente las gráficas de polos y de varianza,
ya que estas aparecían con intervalos en blanco sin saber muy bien la razón. Tras indagar sobre el tema, se encontró cual era la causa
del problema y se solucionó. Parece ser que la interrupción que se había activado para el control del tiempo por milisegundos a veces
no era lo bastante rápida ya que la interrupción encargada de tomar datos en los flancos de subida o bajada de los pines de los que obtenemos
los datos de movimiento del motor parecía ser más rápida, por lo que tomaba varios datos en el mismo instante de tiempo. Para solucionar este
contratiempo, se ha realizado una media de los tiempos al mismo tiempo que se realiza la media de los datos de tensión. Esta modificación del
software realizado en matlab se encuentra en el repositorio GitHub.


\section{Análisis, diseño e implementación de un controlador P para un control de posición angular}

--sección vacía

\section{Conclusiones}

--sección vacía



\begin{thebibliography}{99}
\bibitem{git} \href{https://github.com/jjalberca/reallabo2018}{Repositorio del proyecto alojado en GitHub}
\bibitem{modelado} Félix Monasterio-Huelin y Álvaro Gutiérrez: \href{http://robolabo.etsit.upm.es/asignaturas/seco/apuntes/modelado.pdf}{Modelado de un motor DC}
\end{thebibliography}


\end{document}
